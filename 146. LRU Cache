class LRUCache {
public:
    LRUCache(int capacity): capacity_(capacity) {
    }
    
    int get(int key) {
        auto it = node_map_.find(key);
        if (it == node_map_.end()) {
            return -1;
        }
        const auto& node_it = it->second;
        node_list_.push_front(make_pair(node_it->first, node_it->second));
        node_list_.erase(node_it);
        it->second = node_list_.begin();
        return it->second->second;
    }
    
    void put(int key, int value) {
        auto it = node_map_.find(key);
        if (it == node_map_.end()) {
            if (node_map_.size() >= capacity_) {
                auto node = node_list_.back();
                auto key = node.first;
                node_list_.pop_back();
                node_map_.erase(key);
            }
            node_list_.push_front(make_pair(key,value));
            auto node_it = node_list_.begin();
            node_map_.insert(make_pair(key, node_it));
        } else {
            auto& node_it = it->second;
            node_list_.push_front(make_pair(node_it->first, value));
            node_list_.erase(node_it);
            it->second = node_list_.begin();
        }
    }
      
private:
    int capacity_;
    list<pair<int, int>> node_list_;
    unordered_map<int, list<pair<int, int>>::iterator> node_map_;
};
